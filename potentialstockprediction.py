# -*- coding: utf-8 -*-
"""PotentialStockPrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12zV_mxBPLE21vUtBQsxcucqGYlTIMMkT

# **FINAL PROJECT** - Columbia Engineering 2021

# **Potential Stock Prediction**

### **Using nbinteract CLI Usage as #nbi:hide_in to hide our Python Code**

## **PART #1** - Packages Installation.

First, let's install all dependencies to have our Software up to date and with all tools that we need.
"""

#nbi:hide_in

!pip install nbinteract

#nbi:hide_in

# The next two commands can be skipped for notebook version 5.3 and above

#Currently using version of the notebook server is: 6.1.4

#CODE if you have an older version:
#jupyter nbextension enable --py --sys-prefix bqplot
#jupyter nbextension enable --py --sys-prefix widgetsnbextension

#nbi:hide_in

!pip install sklearn

#nbi:hide_in

!pip install yfinance

#nbi:hide_in

!pip install ipywidgets

#nbi:hide_in

!pip install pandas

#nbi:hide_in

!pip install pandas-datareader

#nbi:hide_in

!pip install numpy

#nbi:hide_in

!pip install plotly

#nbi:hide_in

!pip install datetime

"""## **PART #2**

## **Import ipywidgets to interact Jupyter Notebook over HTML**

### Key Feature is "Yahoo! Finance" to downloading histrocial market data.
"""

#nbi:hide_in

from ipywidgets import interact

#nbi:hide_in

import pandas as pd 
from pandas_datareader import data 
import plotly.graph_objects as go 
import plotly.express as px # Plotly Dark Templates
import yfinance as yf # Key Import
from datetime import date 
from dateutil.relativedelta import relativedelta 
import numpy as np 
from sklearn.linear_model import LinearRegression # Machine Leraning (Linear Model)
from sklearn.model_selection import train_test_split # Machine Leraning (Train and Tool Model)

"""Below the Bash Colors in Python from **python_bash_font** GitHub"""

#nbi:hide_in

class color:
   RED = '\033[91m'
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   PURPLE = '\033[95m'
   GREEN = '\033[92m'
   YELLOW = '\033[93m'
   CYAN = '\033[96m'
   DARKCYAN = '\033[36m'
   BLUE = '\033[94m'
   END = '\033[0m'

"""# **PART #3**

# **INTERACT TEST CODE:**

### Using Interact
The ipywidgets library provides the simplest way to get started writing interactive documents. Although the library itself has its own documentation, we will provide a quick overview to let you get started as quickly as possible.
"""

#nbi:hide_in

#Testing Interact from ipywidgets
def square(x):
    return x * x

interact(square, x=10);

#nbi:hide_in

interact(square, x=(0, 100, 10));

#nbi:hide_in

def friends(name, number):
    return '{} has {} friends!'.format(name, number)

#nbi:hide_in

interact(friends, name='George Quinanilla', number=(5, 10));

#nbi:hide_in

interact(friends, name='Charlie Burd', number={'One': 1, 'Five': 5, 'Ten': 10});

## Now we can move on to CORE CODE!

"""# **CORE CODE:**

As Machine Learning, our SVR (SVM) Model predicts from Yahoo Finance Librery Stock Historcal source.

From Pandas, "pandas_datareader" we're using "data" library, It's important because help during the process imported every time the END USER Ineraction.
"""

from pandas_datareader import data


# Date Vars Definicion (YYY-MM-DD)
start_date = '2020-01-01'
end_date = '2020-01-15'


# WHILE-TRUE as END USER Inputs for DataFrame interaction with Yahoo Finance.
# From PANDAS, DATAREADER to get our Final Data interaction.
while True:
    try:
        symbol = input('Enter a valid Stock Tricker Symbol: ')
        # We're using the "symbol" as Stock ticker, then "yahoo" for Yahoo Finance historial data, and last, "start_date" and "end_date" as Date manual input search criteria. 
        df = data.DataReader(symbol, 'yahoo', start_date, end_date)
        break
    # As en error respond: (Example: An invalid Stock Symbol) our END USER gerts the below to submit a valid ticker. 
    except(KeyError, OSError):
        print(color.RED + color.DARKCYAN + f'> {symbol} is not a valid Stock Symbol. Please submit a valid Stock Symbol, Example: BAC for Bank of America' + color.END) 


# NOTE:
        # If we look at the DataFrame "df", we see that there are 6 variables/columns: "High", "Low", "Open", "Close", "Volume" and "Adj Close"
        # We also see that the Index of the "df" is the date (DatetimeIndex)
        # For the Plotting we want to use for the x-axis the date and for the y-axis the Adjusted Close values
        # However, this is only possible if both axes are assigned by variables; this is not the case with the date, because it is the index 
        # Therefore we replace the index with simple sequential numbers and save the old index ("DatetimeIndex") as a variable
        # Now the DataFrame "df" has 7 variables/columns: "Date", High", "Low", "Open", "Close", "Volume" and "Adj Close"


# Make a User Menu
print(color.BOLD + color.UNDERLINE + color.DARKCYAN + '\n> Please select from below an option to Analyzing your Stock Ticker Data:' + color.END)
choice = True
while choice:
    print(f'''\n SELECT FROM THE BELOW YOUR ANALYSIS OPTION: \n
    1 - Machine Learning 15 days Prediction (SVR Model) from Your Stock "{symbol}" Tricker.
    2 - Machine Learning 30 days Prediction (SVR Model) from Your Stock "{symbol}" Tricker.
    3 - Price Date Range Chart (YYY-MM-DD) from your Stock "{symbol}" Tricker.
    4 - Price Comparison from your Stock "{symbol}" Tricker with another Tricker.
    5 - Your Stock "{symbol}" Tricker 180 Past-Days Analysis.

    Q - Quit and Restart the Process using different Symbol or Stock Tricker.
    ''')
    choice = (input('''\nPlease select a Numeric Option (Example: For the Second Option type "1" and or "Q" to Quit.): '''))
    
    
    
    
    
    
    # ALL CONDITIONS (1 to 5 including Q option)
    
    # OPTION 1: Machine Learning 15 days Prediction from Your Stock "{symbol}" Tricker.
    if choice == '1' or choice == 'A' or choice == 'a':
        # Get the date of today
        today = date.today()
        # Change the format
        today = today.strftime('%Y-%m-%d')

        # Get the stock data, starting from 2000-01-01 to today
        df = data.DataReader(symbol, 'yahoo', '2000-01-01', 'today')
        # For the prediction we only need the column/variable "Adj Close"
        df = df[['Adj Close']]

        # Creating a variable "n" for predicting the amount of days in the future
        # We predict the stock price 15 days in the future
        n = 15

        # Create another column "Prediction" shifted "n" units up
        df['Prediction'] = df[['Adj Close']].shift(-n)
        # We shifted the data up 15 rows, so that for every date we have the actual price ("Adj Close") and the predicted price 15 days into the future ("Prediction") 
        # Therefore the last 15 rows of the column "Prediction" will be empty or contain the value "NaN"

        # Creating independent data set "X"
        # For the independent data we dont need the column "Prediction"
        X = df.drop(['Prediction'],1)
        # Convert the data into a numpy array 
        X = np.array(X)
        # Remove the last "n" rows
        X = X[:-n]

        # Create the dependent data set "Y"
        # For the dependent data we need the column "Prediction"
        Y = df['Prediction']
        # Convert the data into a numpy array 
        Y = np.array(Y)
        # Remove the last "n" rows
        Y = Y[:-n]

        # Split the data into 80% train data and 20 % test data
        x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2)

        # Create Linear Regression Model
        lr = LinearRegression()
        # Train the model
        lr.fit(x_train, y_train)

        # Set "forecast" to the last 15 rows of the original data set from "Adj Close" column
        # We dont need the column 'Prediction'
        # Convert the data into a numpy array
        # We want the last 15 rows  
        forecast = np.array(df.drop(['Prediction'],1))[-n:]


        # Print the predictions for the next "n" days
        # "lr_prediction" contains the price values, which the Linear Regression Model has predicted for the next "n" (15) days
        lr_prediction = lr.predict(forecast)

        # Now we save the predictions in a DataFrame called "predictions"
        predictions = pd.DataFrame(lr_prediction, columns = ['Prediction'])
        # "predictions" has 1 column with the predicted values
        # However to plot the value we need another variable/column, which indicates the respective date

        # Therefore we replace the index of the initial data set with simple sequential numbers and save the old index ("DatetimeIndex") as a variable "Date"
        df = df.reset_index()

        # From "Date" we need the to get the last value which is the latest date and add 1 day, because that's the date when our predictions start
        d = df['Date'].iloc[-1]
        d = d + relativedelta(days =+ 1)

        # Now we make a list with the respective daterange, beginning from the startdate of our predictions and ending 15 days after
        datelist = pd.date_range(d, periods = 15).tolist()
        # We add the variable to our Dataframe "predictions"
        predictions['Date'] = datelist
        # Now we have a Dataframe with our predicted values and the correspondig dates

        
        # Save the date of today 4 months ago, by subtracting 4 months from the date of today
        six_months = date.today() - relativedelta(months=+4)
        six_months = six_months.strftime('%Y-%m-%d')

        # Get the data for plotting
        df = data.DataReader(symbol, 'yahoo', six_months, today)
        df = df.reset_index()


        # Plotting the chart
        fig = go.Figure()
        # Add the data from the first stock
        fig.add_trace(go.Scatter(
                        x=df.Date,
                        y=df['Adj Close'],
                        name=f'{symbol} stock',
                        line_color='dodgerblue',
                        opacity=0.9))
        
        # Add the data from the predictions
        fig.add_trace(go.Scatter(
                        x=predictions.Date,
                        y=predictions['Prediction'],
                        name=f'ML Prediction',
                        line=dict(color='green', dash = 'dot'),
                        opacity=0.9))
    
        fig.update_layout(title=f'Historical {symbol} Quote Stock Value - With 15 Days Prediction',
                                    yaxis_title='Closing Day Price Value in USD',
                                    template='plotly_dark',
                                    xaxis_tickfont_size=14,
                                    yaxis_tickfont_size=14)
        
        fig.show()


   
    
    
    # OPTION 2: Machine Learning 30 days Prediction from Your Stock "{symbol}" Tricker.
    # Same model as above, but using 4 Months data for 30 precition price. 

    elif choice == '2' or choice == 'B' or choice == 'b':
        
        # Get the date of today
        today = date.today()
        # Change the format
        today = today.strftime('%Y-%m-%d')

        # Get the stock data, starting from 2000-01-01 to today
        df = data.DataReader(symbol, 'yahoo', '2000-01-01', 'today')
        # For the prediction we only need the column/variable "Adj Close"
        df = df[['Adj Close']]

        # Creating a variable "n" for predicting the amount of days in the future
        # We predict the stock price 30 days in the future
        n = 30

        # Create another column "Prediction" shifted "n" units up
        df['Prediction'] = df[['Adj Close']].shift(-n)
        # We shifted the data up 30 rows, so that for every date we have the actual price ("Adj Close") and the predicted price 30 days into the future ("Prediction") 
        # Therefore the last 30 rows of the column "Prediction" will be empty or contain the value "NaN"

        # Creating independent data set "X"
        # For the independent data we dont need the column "Prediction"
        X = df.drop(['Prediction'],1)
        # Convert the data into a numpy array 
        X = np.array(X)
        # Remove the last "n" rows
        X = X[:-n]

        # Create the dependent data set "Y"
        # For the dependent data we need the column "Prediction"
        Y = df['Prediction']
        # Convert the data into a numpy array 
        Y = np.array(Y)
        # Remove the last "n" rows
        Y = Y[:-n]

        # Split the data into 80% train data and 20 % test data
        x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2)

        # Create Linear Regression Model
        lr = LinearRegression()
        # Train the model
        lr.fit(x_train, y_train)

        # Set "forecast" to the last 30 rows of the original data set from "Adj Close" column
        # We dont need the column 'Prediction'
        # Convert the data into a numpy array
        # We want the last 30 rows  
        forecast = np.array(df.drop(['Prediction'],1))[-n:]


        # Print the predictions for the next "n" days
        # "lr_prediction" contains the price values, which the Linear Regression Model has predicted for the next "n" (30) days
        lr_prediction = lr.predict(forecast)

        # Now we save the predictions in a DataFrame called "predictions"
        predictions = pd.DataFrame(lr_prediction, columns = ['Prediction'])
        # "predictions" has 1 column with the predicted values
        # However to plot the value we need another variable/column, which indicates the respective date

        # Therefore we replace the index of the initial data set with simple sequential numbers and save the old index ("DatetimeIndex") as a variable "Date"
        df = df.reset_index()

        # From "Date" we need the to get the last value which is the latest date and add 1 day, because that's the date when our predictions start
        d = df['Date'].iloc[-1]
        d = d + relativedelta(days =+ 1)

        # Now we make a list with the respective daterange, beginning from the startdate of our predictions and ending 30 days after
        datelist = pd.date_range(d, periods = 30).tolist()
        # We add the variable to our Dataframe "predictions"
        predictions['Date'] = datelist
        # Now we have a Dataframe with our predicted values and the correspondig dates

        
        # Save the date of today 6 months ago, by subtracting 6 months from the date of today
        twelve_months = date.today() - relativedelta(months=+6)
        twelve_months = twelve_months.strftime('%Y-%m-%d')

        # Get the data for plotting
        df = data.DataReader(symbol, 'yahoo', twelve_months, today)
        df = df.reset_index()



        fig = go.Figure()

        fig.add_trace(go.Scatter(
                        x=df.Date,
                        y=df['Adj Close'],
                        name=f'{symbol} stock',
                        line_color='dodgerblue',
                        opacity=0.9))
        

        fig.add_trace(go.Scatter(
                        x=predictions.Date,
                        y=predictions['Prediction'],
                        name=f'ML Prediction',
                        line=dict(color='green', dash = 'dot'),
                        opacity=0.9))
    
        fig.update_layout(title=f'Historical {symbol} Quote Stock Value - With 30 Days Prediction',
                                    yaxis_title='Closing Day Price Value in USD',
                                    template='plotly_dark',
                                    xaxis_tickfont_size=14,
                                    yaxis_tickfont_size=14)
        
        fig.show()





    # OPTION 3: Price Date Range Chart from Date Selected. 

    elif choice == '3' or choice == 'C' or choice == 'c':
    
        start_date = input('\nSubmit you Starting Date Analysis (With YYYY-MM-DD Format): ')
        end_date = input('Submit you Ending Date Analysis (With YYYY-MM-DD Format): ')
    
        df = data.DataReader(symbol, 'yahoo', start_date, end_date)
    
        df = df.reset_index()

        fig = go.Figure()
        fig.add_trace(go.Scatter(x=df.Date,
                                 y=df['Adj Close'],
                                 line_color='dodgerblue'))
        
        fig.update_layout(title=f'{symbol} Stock Price from {start_date} to {end_date}',
                                    yaxis_title='Closing Day Price Value in USD',
                                    template='plotly_dark',
                                    xaxis_tickfont_size=14,
                                    yaxis_tickfont_size=14)

        fig.show()
     
    
    



    # OPTION 4: Price Comparison from your Stock Tricker.
    elif choice == '4' or choice == 'D' or choice == 'd':
        start_date = input('\nSubmit you Starting Date Analysis (With YYYY-MM-DD Format): ')
        end_date = input('Submit you Ending Date Analysis (With YYYY-MM-DD Format): ')
    
        df = data.DataReader(symbol, 'yahoo', start_date, end_date)
        df = df.reset_index()
        
        while True:
            try:
                symbol_2 = input(f'\nWith which stock would you like to compare {symbol} stock? \nPlease enter a valid Stock Symbol: ')
                df_2 = data.DataReader(symbol_2, 'yahoo', start_date, end_date)
                df_2 = df_2.reset_index()
                break
            except(KeyError, OSError):
                print(color.BOLD + color.UNDERLINE + f'> {symbol_2} is not a valid stock symbol. Please try again...' + color.END)

                
        fig = go.Figure()

        fig.add_trace(go.Scatter(
                    x=df.Date,
                    y=df['Adj Close'],
                    name=f'{symbol} Stock',
                    line_color='dodgerblue',
                    opacity=0.9))
        
        fig.add_trace(go.Scatter(
                    x=df_2.Date,
                    y=df_2['Adj Close'],
                    name=f'{symbol_2} Stock',
                    line_color='dimgray',
                    opacity=0.9))
    
    
        fig.update_layout(title=f'Price Comparison of {symbol} Stock and {symbol_2} Stock from {start_date} to {end_date}', 
                                    yaxis_title='Closing Day Price Value in USD',
                                    template='plotly_dark',
                                    xaxis_tickfont_size=14,
                                    yaxis_tickfont_size=14)
        
        fig.show()
    

        
   
    
    
    # Option 5: Your Stock Tricker 180 Past-Days Analysis.
    elif choice == '5' or choice == 'E' or choice == 'e':

        try:
            # Save the date of today in the variable "today"
            today = date.today()
            # We convert the type of the variable in the format %Y-%m-%d
            today = today.strftime('%Y-%m-%d')
            # Save the date of today 6 months ago, by subtracting 6 months from the date of today
            six_months = date.today() - relativedelta(months=+6)
            six_months = six_months.strftime('%Y-%m-%d')
        
            df2 = yf.Ticker(symbol)
            # Save the Analyst Recommendations in "rec"
            rec = df2.recommendations
            # The DataFrame "rec" has 4 columns: "Firm", "To Grade", "From Grade" and "Action"
            # The index is the date ("DatetimeIndex")
    
            # Now we select only those columns which have the index(date) from "six months" to "today"
            rec = rec.loc[six_months:today,]
        
            # Unfortunately in some cases no data is available, so that the DataFrame is empty. Then the user gets the following message
            if rec.empty:
                print(color.BOLD + color.UNDERLINE + "\n> Unfortunately, there are no recommendations by analysts provided for your chosen stock!" + color.END)
                    
                    
            else:    
                # Replace the index with simple sequential numbers and save the old index ("DatetimeIndex") as a variable "Date"
                rec = rec.reset_index()
    
                # For our analysis we don't need the variables/columns "Firm", "From Grade" and "Action", therefore we delete them
                rec.drop(['Firm', 'From Grade', 'Action'], axis=1, inplace=True)

                # We change the name of the variables/columns
                rec.columns = (['date', 'grade'])
        
                # Now we add a new variable/column "value", which we give the value 1 for each row in order to sum up the values based on the contents of "grade"
                rec['value'] = 1

                # Now we group by the content of "grade" and sum their respective values 
                rec = rec.groupby(['grade']).sum()
                # The DataFrame "rec" has now 1 variable/column which is the value, the index are the different names from the variable "grade"
                # However for the plotting we need the index as a variable 
                rec = rec.reset_index()
        
                # For the labels we assign the content/names of the variable "grade" and for the values we assign the content of "values" 
                fig = go.Figure(data=[go.Pie(labels=rec.grade,
                                                values=rec.value,
                                                hole=.3)])
                # Give a title
                fig.update_layout(template='plotly_dark', title_text=f'Analyst Recommendations of {symbol} Stock from {six_months} to {today}')

                # Plotting the chart
                fig.show()  
            

    
        # For some stocks the imported data is distorted and in a wrong format, so that an error appears
        # In this cases the user gets the following message:
        except(ValueError,AttributeError):
            print(color.BOLD + color.UNDERLINE + '\n> Unfortunately, there are no recommendations provided for your chosen stock!' + color.END) 

 

    
    # OPTION 6: Quit the program
    elif choice == '6' or choice == 'Q' or choice == 'q':
        print(color.BLUE + color.BOLD + '\n> If you like our results, please share our solution with others! Thank you!' + color.END)
        choice = None
        

    # If user inputs a non valid option
    else:
        print(color.BOLD + color.UNDERLINE + '\n> Your Selection is INVALID! Please select a correct Option from our list.' + color.END)



"""**Potential Stock Prediction**"""